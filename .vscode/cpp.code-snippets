{
	"LeetCode Solution Template": {
		"prefix": "lcsol",
		"body": [
			"#include <iostream>",
			"#include <vector>",
			"#include <queue>",
			"#include <map>",
			"",
			"using namespace std;",
			"",
			"class Solution {",
			"    public:",
			"        ${1:returnType} ${2:methodName}(${3:parameters}) {",
			"            $0",
			"        }",
			"};",
			"",
			"int main() {",
			"    Solution sol;",
			"    ",
			"    return 0;",
			"}"
		],
		"description": "LeetCode solution template with Solution class and main"
	},
	"TreeNode Definition": {
		"prefix": "treenode",
		"body": [
			"// Definition for a binary tree node.",
			"struct TreeNode {",
			"    int val;",
			"    TreeNode *left;",
			"    TreeNode *right;",
			"    TreeNode() : val(0), left(nullptr), right(nullptr) {}",
			"    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}",
			"    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}",
			"};"
		],
		"description": "Binary tree node structure definition"
	},
	"BFS Template": {
		"prefix": "bfs",
		"body": [
			"queue<${1:Type}*> q;",
			"q.push(${2:root});",
			"",
			"while(!q.empty()) {",
			"    ${1:Type}* front = q.front();",
			"    $0",
			"    if(front->left)",
			"        q.push(front->left);",
			"    if(front->right)",
			"        q.push(front->right);",
			"    q.pop();",
			"}"
		],
		"description": "Breadth-first search template"
	},
	"DFS Template": {
		"prefix": "dfs",
		"body": [
			"void dfs(${1:TreeNode}* root${2:, int depth}) {",
			"    if(root) {",
			"        $0",
			"        dfs(root->left${2:, depth+1});",
			"        dfs(root->right${2:, depth+1});",
			"    }",
			"}"
		],
		"description": "Depth-first search template"
	},
	"Vector Loop": {
		"prefix": "vloop",
		"body": [
			"for(int i = 0; i < ${1:vec}.size(); i++) {",
			"    $0",
			"}"
		],
		"description": "Vector loop with index"
	},
	"Range-based For Loop": {
		"prefix": "rloop",
		"body": [
			"for(${1:auto} ${2:item} : ${3:container}) {",
			"    $0",
			"}"
		],
		"description": "Range-based for loop"
	},
	"Two Pointers": {
		"prefix": "twoptr",
		"body": [
			"int left = 0;",
			"int right = ${1:vec}.size() - 1;",
			"",
			"while(left < right) {",
			"    $0",
			"    ",
			"    if(${2:condition}) {",
			"        left++;",
			"    } else {",
			"        right--;",
			"    }",
			"}"
		],
		"description": "Two pointers pattern"
	},
	"Sliding Window": {
		"prefix": "sliding",
		"body": [
			"int left = 0;",
			"int right = 0;",
			"",
			"while(right < ${1:vec}.size()) {",
			"    $0",
			"    ",
			"    while(${2:condition}) {",
			"        left++;",
			"    }",
			"    ",
			"    right++;",
			"}"
		],
		"description": "Sliding window pattern"
	}
}
